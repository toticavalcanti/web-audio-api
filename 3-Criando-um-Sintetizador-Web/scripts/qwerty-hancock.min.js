/*
 * Qwerty Hancock keyboard library v0.6.0
 * The web keyboard for now people.
 * Copyright 2012-18, Stuart Memo
 *
 * Licensed under the MIT License
 * http://opensource.org/licenses/mit-license.php
 *
 * http://stuartmemo.com/qwerty-hancock
 */

(function () {
    var root = this;
    /* No contexto do <script>, `this` é a janela.
     * No contexto do nó (browserify), `this` é o nó global.
     */
    var globalWindow = typeof global === 'undefined' ? root : root.window;
    var version = '0.6.0',
        settings = {},
        mouse_is_down = false,
        keysDown = {},
        key_map = {
            65: 'Cl',
            87: 'C#l',
            83: 'Dl',
            69: 'D#l',
            68: 'El',
            70: 'Fl',
            84: 'F#l',
            71: 'Gl',
            89: 'G#l',
            90: 'G#l',
            72: 'Al',
            85: 'A#l',
            74: 'Bl',
            75: 'Cu',
            79: 'C#u',
            76: 'Du',
            80: 'D#u',
            59: 'Eu',
            186: 'Eu',
            222: 'Fu',
            221: 'F#u',
            220: 'Gu'
        },
        keyDownCallback,
        keyUpCallback;

    /**
     * Calcula a largura da tecla branca.
     * @return {number} Largura de uma única tecla branca em pixel.
     */
    var getWhiteKeyWidth = function (number_of_white_keys) {
        return Math.floor((settings.width - number_of_white_keys) / number_of_white_keys);
    };

    /**
     * Mesclar configurações de usuário com padrões.
     * @param  {object} user_settings
     */
    var init = function (us) {
        var container;

        user_settings = us || {};

        settings = {
            // atribui a chave id a string keyboard, caso não seja passado nada pelo user_settings.id
            id:             user_settings.id || 'keyboard',
            // define que o teclado terá 3 oitavas, caso não seja passado nada pelo user_settings.octaves
            octaves:        user_settings.octaves || 3,
            // pega o valor da largura pelo user_settings.width
            width:          user_settings.width,
            // Mesma coisa para o height
            height:         user_settings.height,
            // Define que o teclado vai começar pela nota A3 (Lá 3)
            startNote:      user_settings.startNote || 'A3',
            // Define a cor das teclas brancas do teclado em hexa
            whiteKeyColour: user_settings.whiteKeyColour || '#fff',
            // Define a cor das teclas pretas do teclado em hexa
            blackKeyColour: user_settings.blackKeyColour || '#000',
            // Define a cor da tecla ativa, isto é, que tá sendo pressionada, para a cor azul.
            activeColour:   user_settings.activeColour || '#428bca',
            // Define a cor da borda das teclas como preto
            borderColour:   user_settings.borderColour || '#000'
        };
        // Pega o id do elemento no html, no nosso caso, o id é keyboard
        container = document.getElementById(settings.id);
        // Se a largura(width) não for definido no settings, ele pega a largura 
        // através do container, que é o elemento keyboard, com o offsetWidth
        if (typeof settings.width === 'undefined') {
            settings.width = container.offsetWidth;
        }
        // Mesma coisa para a altura(height)
        if (typeof settings.height === 'undefined') {
            settings.height = container.offsetHeight;
        }
        // define a oitava inicial, pegando o 3 da string A3, que é a nota inicial.
        // "A3".charAt(1), 10) retorna só o "3", que passa no parseInt e vira 3.
        settings.startOctave = parseInt(settings.startNote.charAt(1), 10);
        // Define a oitava inicial com 3, pego no comando anterior, caso não seja passado
        // um valor para user_settings.keyOctave no synth.js como parâmetro octaves.
        settings.keyOctave = user_settings.keyOctave || settings.startOctave;

        // Adiciona getters e setters
        this.setKeyOctave = function(octave){
            settings.keyOctave = octave;
            return settings.keyOctave;
        }
        this.getKeyOctave = function(){
            return settings.keyOctave;
        }
        this.keyOctaveUp = function(){
            settings.keyOctave++;
            return settings.keyOctave;
        }
        this.keyOctaveDown = function(){
            settings.keyOctave--;
            return settings.keyOctave;
        }
        this.getKeyMap = function(){
            return key_map;
        }
        this.setKeyMap = function(newKeyMap){
            key_map = newKeyMap;
            return key_map;
        }

        createKeyboard();
        addListeners.call(this, container);
    };

    /**
     * Obtém frequência de uma determinada nota.
     * @param  {string} note Nota musical para converter em hertz.
     * @return {number} Frequência de nota em hertz.
     */
    var getFrequencyOfNote = function (note) {
        var notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'],
            key_number,
            octave;

        if (note.length === 3) {
            octave = note.charAt(2);
        } else {
            octave = note.charAt(1);
        }

        key_number = notes.indexOf(note.slice(0, -1));

        if (key_number < 3) {
            key_number = key_number + 12 + ((octave - 1) * 12) + 1;
        } else {
            key_number = key_number + ((octave - 1) * 12) + 1;
        }

        return 440 * Math.pow(2, (key_number - 49) / 12);
    };

    /**
     * Alterar a cor de uma tecla.
     * @param  {element} el Elemento DOM para mudar a cor.
     */
    var lightenUp = function lightenUp (el) {
        if (el !== null || typeof el === undefined) {
            el.style.backgroundColor = settings.activeColour;
        }
    };

    /**
     * Reverte a tecla para a cor original.
     * @param  {element} el Elemento DOM para mudar a cor.
     */
    var darkenDown = function darkenDown (el) {
        if (el !== null) {
            if (el.getAttribute('data-note-type') === 'white') {
                el.style.backgroundColor = settings.whiteKeyColour;
            } else {
                el.style.backgroundColor = settings.blackKeyColour;
            }
        }
    };

    /**
     * Ordena as notas na ordem definida pela tecla inicial nas configurações.
     * @param {array} notes_to_order Notas a serem ordenadas.
     * @return {array{ ordered_notes Notas ordenadas.
     */
    var orderNotes = function (notes_to_order) {
        var i,
            keyOffset = 0,
            number_of_notes_to_order = notes_to_order.length,
            ordered_notes = [];

        for (i = 0; i < number_of_notes_to_order; i++) {
            if (settings.startNote.charAt(0) === notes_to_order[i]) {
                keyOffset = i;
                break;
            }
        }

        for (i = 0; i < number_of_notes_to_order; i++) {
            if (i + keyOffset > number_of_notes_to_order - 1) {
                ordered_notes[i] = notes_to_order[i + keyOffset - number_of_notes_to_order];
            } else {
                ordered_notes[i] = notes_to_order[i + keyOffset];
            }
        }

        return ordered_notes;
    };

    /**
     * Adiciona estilo a uma tecla branca individual.
     * @param  {element} el Elemento DOM tecla branca.
     */
    var styleWhiteKey = function (key) {
        key.el.style.backgroundColor = settings.whiteKeyColour;
        key.el.style.border = '1px solid ' + settings.borderColour;
        key.el.style.borderRight = 0;
        key.el.style.height = settings.height + 'px';
        key.el.style.width = key.width + 'px';
        key.el.style.borderRadius = '0 0 5px 5px';

        if (key.noteNumber === getTotalWhiteKeys() - 1) {
            key.el.style.border = '1px solid ' + settings.borderColour;
        }
    };

    /**
     * Adiciona estilo a uma tecla preta individual.
     * @param  {element} el Elemento DOM tecla preta.
     */
    var styleBlackKey = function (key) {
        var white_key_width = getWhiteKeyWidth(getTotalWhiteKeys()),
            black_key_width = Math.floor(white_key_width / 2);

        key.el.style.backgroundColor = settings.blackKeyColour;
        key.el.style.border = '1px solid ' + settings.borderColour;
        key.el.style.position = 'absolute';
        key.el.style.left = Math.floor(((white_key_width + 1) * (key.noteNumber + 1)) - (black_key_width / 2)) + 'px';
        key.el.style.width = black_key_width + 'px';
        key.el.style.height = (settings.height / 1.5) + 'px';
        key.el.style.borderRadius = '0 0 3px 3px';
    };

    /**
    * Adiciona um estilo a uma tecla individual no teclado.
    * @param  {object} key Elemento tecla.
    */
    var styleKey = function (key) {
        key.el.style.display = 'inline-block';
        key.el.style['-webkit-user-select'] = 'none';

        if (key.colour === 'white') {
            styleWhiteKey(key);
        } else {
            styleBlackKey(key);
        }
    };

    /**
    * Redefinir estilos no contêiner de teclado e no elemento de lista.
    * @param {element} keyboard container do elemento DOM teclado.
    */
    var styleKeyboard = function (keyboard) {
        var styleElement = function (el) {
            el.style.cursor = 'default';
            el.style.fontSize = '0px';
            el.style.height = settings.height + 'px';
            el.style.padding = 0;
            el.style.position = 'relative';
            el.style.listStyle = 'none';
            el.style.margin = 0;
            el.style.width = settings.width + 'px';
            el.style['-webkit-user-select'] = 'none';
        };

        styleElement(keyboard.container);
        styleElement(keyboard.el);
    };

    /**
    * Chama o evento mouseDown do usuário.
    */
    var mouseDown = function (element, callback) {
        if (element.tagName.toLowerCase() == 'li') {
            mouse_is_down = true;
            lightenUp(element);
            callback(element.title, getFrequencyOfNote(element.title));
        }
    };

    /**
    * Chama o evento mouseUp do usuário.
    */
    var mouseUp = function (element, callback) {
        if (element.tagName.toLowerCase() == 'li') {
            mouse_is_down = false;
            darkenDown(element);
            callback(element.title, getFrequencyOfNote(element.title));
        }
    };

    /**
    * Chama mouseDown do usuário, se necessário.
    */
    var mouseOver = function (element, callback) {
        if (mouse_is_down) {
            lightenUp(element);
            callback(element.title, getFrequencyOfNote(element.title));
        }
    };

    /**
    * Chama o mouseUp do usuário, se necessário.
    */
    var mouseOut = function (element, callback) {
        if (mouse_is_down) {
            darkenDown(element);
            callback(element.title, getFrequencyOfNote(element.title));
        }
    };

    /**
    * Cria o elemento DOM tecla.
    * @return {object} Key DOM element.
    */
    var createKey = function (key) {
        key.el = document.createElement('li');
        key.el.id = key.id;
        key.el.title = key.id;
        key.el.setAttribute('data-note-type', key.colour);

        styleKey(key);

        return key;
    };
    
    // Retorna o total de teclas brancas fazendo uma conta simples,
    // cada oitava tem 7 notas brancas, então multiplica-se o 7 pelo 
    // número de oitavas que queremos no teclado
    var getTotalWhiteKeys = function () {
        return settings.octaves * 7;
    };
    // Cria as teclas do teclado
    var createKeys = function () {
        var that = this,
            i,
            key,
            keys = [],
            note_counter = 0,
            octave_counter = settings.startOctave,
            total_white_keys = getTotalWhiteKeys();

        for (i = 0; i < total_white_keys; i++) {

            if (i % this.whiteNotes.length === 0) {
                note_counter = 0;
            }

            bizarre_note_counter = this.whiteNotes[note_counter];

            if ((bizarre_note_counter === 'C') && (i !== 0)) {
                octave_counter++;
            }

            key = createKey({
                colour: 'white',
                octave: octave_counter,
                width: getWhiteKeyWidth(total_white_keys),
                id: this.whiteNotes[note_counter] + octave_counter,
                noteNumber: i
            });

            keys.push(key.el);

            if (i !== total_white_keys - 1) {
                this.notesWithSharps.forEach(function (note, index) {
                    if (note === that.whiteNotes[note_counter]) {
                        key = createKey({
                            colour: 'black',
                            octave: octave_counter,
                            width: getWhiteKeyWidth(total_white_keys) / 2,
                            id: that.whiteNotes[note_counter] + '#' + octave_counter,
                            noteNumber: i
                        });

                        keys.push(key.el);
                    }
                });
            }
            note_counter++;
        }

        return keys;
    };

    var addKeysToKeyboard = function (keyboard) {
        keyboard.keys.forEach(function (key) {
            keyboard.el.appendChild(key);
        });
    };

    var setKeyPressOffset = function (sorted_white_notes) {
        settings.keyPressOffset = sorted_white_notes[0] === 'C' ? 0 : 1;
    };
    // Definição do dicionário keyboard
    // Note o el, através dele as teclas são mostradas no HTML como uma lista('ul')
    var createKeyboard = function () {
        var keyboard = {
            container: document.getElementById("settings.id"),
            el: document.createElement('ul'),
            whiteNotes: orderNotes(['C', 'D', 'E', 'F', 'G', 'A', 'B']),
            notesWithSharps: orderNotes(['C', 'D', 'F', 'G', 'A']),
        };

        keyboard.keys = createKeys.call(keyboard);

        setKeyPressOffset(keyboard.whiteNotes);
        styleKeyboard(keyboard);

        // Adiciona as teclas ao teclado e o teclado ao contêiner.
        addKeysToKeyboard(keyboard);

        keyboard.container.appendChild(keyboard.el);

        return keyboard;
    };

    var getKeyPressed = function (keyCode) {
        return key_map[keyCode]
                .replace('l', parseInt(settings.keyOctave, 10) + settings.keyPressOffset)
                .replace('u', (parseInt(settings.keyOctave, 10) + settings.keyPressOffset + 1)
                .toString());
    };

    /**
     * Manipular uma tecla do teclado sendo pressionada.
     * @param {object} key Evento de teclado - tecla atualmente pressionada.
     * @param {callback} callback A função noteDown do usuário.
     * @return {boolean} true se foi uma tecla (combo) usada por qwerty-hancock
     */
    var keyboardDown = function (key, callback) {
        var key_pressed;

        if (key.keyCode in keysDown) {
           return false;
        }

       keysDown[key.keyCode] = true;

       if (typeof key_map[key.keyCode] !== 'undefined') {
            key_pressed = getKeyPressed(key.keyCode);

            // Chama a função noteDown do usuário.
            callback(key_pressed, getFrequencyOfNote(key_pressed));
            lightenUp(document.getElementById(key_pressed));
            return true;
       }
       return false;
    };

    /**
     * Lida com uma tecla do teclado sendo liberada.
     * @param {element} key O elemento DOM da tecla que foi liberada.
     * @param {callback} callback A função noteDown do usuário.
     * @return {boolean} true se foi uma tecla  (combo) usada por qwerty-hancock
     */
    var keyboardUp = function (key, callback) {
        var key_pressed;

        delete keysDown[key.keyCode];

        if (typeof key_map[key.keyCode] !== 'undefined') {
            key_pressed = getKeyPressed(key.keyCode);
            // Chama a função noteDown do usuário.
            callback(key_pressed, getFrequencyOfNote(key_pressed));
            darkenDown(document.getElementById(key_pressed));
            return true;
        }
        return false;
    };

    /**
     * Determine se a tecla pressionada é uma tecla modificadora ou não 
     * exemplo de teclas modificadoras: Control, Shift, Alt / Option (Apple),
     * AltGr, Meta, Command (Apple) / Windows (Microsoft), Super, Hyper, Fn.
     * @param {KeyboardEvent} O evento keydown de uma tecla pressionada.
     */
    var isModifierKey = function (key) {
        return key.ctrlKey ||  key.metaKey || key.altKey;
    };

    /**
     * Adiciona event listeners ao teclado.
     * @param {element} keyboard_element
     */
    var addListeners = function (keyboard_element) {
        var that = this;

        // A tecla é pressionada no teclado.
        //verifica se a tecla pressionada foi um alt, ou Shift, etc.
        globalWindow.addEventListener('keydown', function (key) {
            if (isModifierKey(key)) {
              return;
            }
            //através da instância do keyboard(this)
            if (keyboardDown(key, that.keyDown)) {
                key.preventDefault();
            }
        });

        // A tecla é liberada no teclado.
        globalWindow.addEventListener('keyup', function (key) {
            if (isModifierKey(key)) {
              return;
            }
            if (keyboardUp(key, that.keyUp)) {
                key.preventDefault();
            }
        });

        // O mouse é clicado no elemento do teclado.
        keyboard_element.addEventListener('mousedown', function (event) {
            mouseDown(event.target, that.keyDown);
        });

        // Mouse é liberado do elemento de teclado.
        keyboard_element.addEventListener('mouseup', function (event) {
            mouseUp(event.target, that.keyUp);
        });

        // Mouse é movido sobre o elemento do teclado.
        keyboard_element.addEventListener('mouseover', function (event) {
            mouseOver(event.target, that.keyDown);
        });

        // Mouse é movido para fora do elemento do teclado.
        keyboard_element.addEventListener('mouseout', function (event) {
            mouseOut(event.target, that.keyUp);
        });

        // O dispositivo suporta eventos de toque.
        if ('ontouchstart' in document.documentElement) {
            keyboard_element.addEventListener('touchstart', function (event) {
                mouseDown(event.target, that.keyDown);
            });

            keyboard_element.addEventListener('touchend', function (event) {
                mouseUp(event.target, that.keyUp);
            });

            keyboard_element.addEventListener('touchleave', function (event) {
                mouseOut(event.target, that.keyUp);
            });

            keyboard_element.addEventListener('touchcancel', function (event) {
                mouseOut(event.target, that.keyUp);
            });
        }
    };

    /**
     * Construtor do Qwerty Hancock.
     * @param {object} settings Configurações do usuário opcionais.
     */
    var QwertyHancock = function (settings) {
        this.version = version;
        init.call(this, settings);
    };

    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = QwertyHancock;
      }
      exports.QwertyHancock = QwertyHancock;
    } else {
      root.QwertyHancock = QwertyHancock;
    }
})(this);